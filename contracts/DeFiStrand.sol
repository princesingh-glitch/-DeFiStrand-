
//MIT
pragma^0.8.20;

import"@openzeppelin/contracts/access/Ownable.sol";
import"@openzeppelin/contracts/utils/Pausable.sol";

/**
@title*AfinancethattogetherDeFi*interconnectedforyieldandmanagement
ProjectOwnable,PausableStructrepresentDeFiStrandname;
addresstotalDeposited;
uint256createdAt;
uint256isActive;
uint8//whereisrisk
}
//toapositionaPositiondepositAmount;
uint256lastClaimTime;
uint256isActive;
}
//forpool
struct{
addresstokenB;
uint256reserveB;
uint256feePercentage;Inpoints300.3%)
}
//variables
mapping(uint256Strand)strands;
mapping(uint256mapping(addressPosition))userPositions;
mapping(uint256LiquidityPool)liquidityPools;
mapping(addressuint256[])userStrandIds;
uint256strandCounter;
uint256poolCounter;
uint256constant=ether;
uint256constant=//annualinpoints
uint256totalValueLocked;
//StrandCreated(uint256strandId,name,indexeduint8DepositMade(uint256strandId,indexeduint256YieldClaimed(uint256strandId,indexeduint256LiquidityAdded(uint256poolId,indexeduint256uint256StrandDeactivated(uint256strandId);
eventindexeduint256Ownable(msg.sender)===*CreatesnewStrandspecified*_nameofstrand
@paramRiskfrom*strandIdIDthecreated*/
functionmemory_riskLevel
)whenNotPaused(uint256)>&&<="Invalidname");
require(_riskLevel1_riskLevel10,levelbe110");
strandCounter++;
uint256==_name,
creator:0,
totalYieldGenerated:block.timestamp,
lastUpdateTime:true,
riskLevel:StrandCreated(newStrandId,msg.sender,newStrandId;
}
/**
@devfundsastrand
@paramIDthetointo
depositToStrand(uint256externalnonReentrant{
require(_strandId0_strandIdstrandCounter,strand"Strandnot>="Deposittoostorage=storage=Ifhasposition,accruedfirst
if&&>{
_calculateAndUpdateYield(_strandId,elseInitializeposition
position.isActivetrue;
position.depositTimeblock.timestamp;
position.lastClaimTimeblock.timestamp;
userStrandIds[msg.sender].push(_strandId);
}
//positionstrand
position.depositAmountmsg.value;
strand.totalDepositedmsg.value;
strand.lastUpdateTimeblock.timestamp;
totalValueLockedmsg.value;
emitmsg.sender,*Claimsyielda*_strandIdofstrandclaim*yieldAmountamountyield*/
function_strandId)nonReentrantreturns{
require(_strandId0_strandIdstrandCounter,strand"Noposition");
_calculateAndUpdateYield(_strandId,storage=yieldAmountposition.accruedYield;
require(yieldAmount0,yieldclaim");
require(address(this).balanceyieldAmount,contractUpdate==Update+=Transfersuccess,=yieldAmount}("");
require(success,transferYieldClaimed(_strandId,yieldAmount);
return*Internaltoandyield
_calculateAndUpdateYield(uint256addressinternalstorage=timeElapsedblock.timestampposition.lastClaimTime;
if>&&>{
//yieldonelapsedyieldFormula:**/days10000)
uint256=**/days10000);
//riskriskLevelstrands[_strandId].riskLevel;
yield(yield(100riskLevel10))100;
position.accruedYieldyield;
}
}
/**
@devliquiditycreateenhanceliquidity*_tokenAoftoken
@paramAddresssecond*_amountAoftoken
@paramAmountsecond*poolIdIDthepool
addLiquidity(
address_tokenB,
uint256_amountB
)nonReentrantreturns{
require(_tokenAaddress(0)_tokenBaddress(0),token!="Tokensbe>&&>"AmountsbethanpoolIdpoolCounter;
liquidityPools[poolId]LiquidityPool({
tokenA:_tokenB,
reserveA:_amountB,
totalLiquidity:+300.3%LiquidityAdded(poolId,_amountA,poolId;
}
/**
@devdetailedaboutstrand
getStrandInfo(uint256externalreturnsmemorycreator,
uint256totalYieldGenerated,
uint256isActive,
uint8{
require(_strandId0_strandIdstrandCounter,strandmemory=(
strand.name,
strand.creator,
strand.totalDeposited,
strand.totalYieldGenerated,
strand.createdAt,
strand.isActive,
strand.riskLevel
);
}
/**
@devuser'sinspecific*/
function_strandId,_user)view(
uint256depositTime,
uint256accruedYield,
bool{
PositionpositionuserPositions[_strandId][_user];
//currentyieldupdatingcurrentYieldposition.accruedYield;
if&&>{
uint256=-(timeElapsed0)additionalYield(position.depositAmountYIELD_RATEtimeElapsed)(365*riskLevelstrands[_strandId].riskLevel;
additionalYield(additionalYield(100riskLevel10))100;
currentYieldadditionalYield;
}
}
return*Getstrandassociateda*/
function_user)view(uint256[]{
return*Getpool*/
function_poolId)view(
addresstokenB,
uint256reserveB,
uint256feePercentage
)>&&<="InvalidID");
LiquidityPoolpoolliquidityPools[_poolId];
return*Deactivatesstrandcreatordeactivate)
deactivateStrand(uint256external>&&<="InvalidID");
require(strands[_strandId].creatormsg.sendermsg.senderowner(),authorized");
require(strands[_strandId].isActive,already=StrandDeactivated(_strandId);
}
/**
@devwithdrawal*/
function_strandId)nonReentrant>&&<="InvalidID");
PositionpositionuserPositions[_strandId][msg.sender];
require(position.isActiveposition.depositAmount0,activewithdrawAmountposition.depositAmount;
//position
position.depositAmount0;
position.isActivefalse;
position.accruedYield0;
//strandTVL
strands[_strandId].totalDepositedwithdrawAmount;
totalValueLockedwithdrawAmount;
//funds
(bool)payable(msg.sender).call{value:"WithdrawalEmergencyWithdrawal(msg.sender,*Pause(only*/
functionexternal{
_pause();
}
/**
@devcontractowner)
unpause()onlyOwner*Getnumberstrands*/
functionexternalreturns{
return*Getvalueinprotocol
getTotalValueLocked()view(uint256)totalValueLocked;
}
/**
@devfunctionaccept*/
receive()payable {}
}
 
Updated on 2025-11-05
 
